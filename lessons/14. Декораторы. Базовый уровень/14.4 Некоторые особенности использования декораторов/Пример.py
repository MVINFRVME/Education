import time
from typing import Callable, Any


def timer(func: Callable) -> Callable:
    """Декоратор, выводящий время, которое заняло
    выполнение декорируемой функции
    """
    def wrapped_func(*args, **kwargs) -> Any:
        started_at = time.time()
        result = func(*args, **kwargs)
        ended_at = time.time()
        run_time = round(ended_at - started_at, 4)
        print('Функция работала {} секунд(ы)'.format(run_time))

        return result
    return wrapped_func


def logging(func: Callable) -> Callable:
    """
    Декоратор, логирующий работу кода
    """
    def wrapped_func(*args, **kwargs) -> Any:
        print('\nВызывается функция: {func}\t'
              'Позиционные аргументы: {args}\t'
              'Именованные аргументы: {kwargs}'.format(
               func=func.__name__, args=args, kwargs=kwargs
                ))
        result = func(*args, **kwargs)
        print('Функция успешно завершила работу')

        return result
    return wrapped_func


@logging
@timer
def squares_sum() -> int:
    number = 2
    result = 0
    for _ in range(number + 1):
        result += sum([i_num ** 2 for i_num in range(2)])

    return result


@timer
@logging
def cubes_sum(number: int) -> int:
    result = 0
    for _ in range(number + 1):
        result += sum([i_num ** 3 for i_num in range(2)])

    return result


# timer(logging(func))
my_sum = squares_sum()
print(my_sum)

new_sum = cubes_sum(10)
print(new_sum)


# Декораторы в Python позволяют модифицировать функции или методы без изменения их исходного кода. Когда вы применяете
# несколько декораторов к одной функции, они взаимодействуют друг с другом в определенном порядке, который имеет
# значение. Давайте рассмотрим, как это происходит на примере ваших декораторов `logging` и `timer`.
#
# Порядок применения декораторов:
# Когда вы применяете несколько декораторов к функции, они оборачиваются (wrap) в порядке сверху вниз
# (то есть декоратор, находящийся ближе к функции, применяется последним). Ваша функция `squares_sum`
# декорируется следующим образом:
#
# python
# @logging
# @timer
# def squares_sum():
#     ...
#
#
# Этот код эквивалентен следующему:

# python
# squares_sum = logging(timer(squares_sum))
#
#
# Таким образом, порядок применения декораторов в данном случае будет следующим:
# 1. **Сначала применяется `timer`**:
# - `timer` принимает `squares_sum` в качестве аргумента. Внутри `timer` создается новая функция `wrapped_func`,
# которая будет выполнять замеры времени выполнения функции.
# 2. **Затем применяется `logging`**:
# - `logging` принимает результат предыдущего завертки, то есть `wrapped_func` из `timer`. Внутри `logging` также
# создается своя новая функция `wrapped_func`, которая будет выполнять логирование.
#
# ### Как выполняются декораторы:
#
# При вызове функции `squares_sum` происходит следующее:
# 1. Вы вызываете `squares_sum()`, но на самом деле вызывается последняя завертка, созданная декоратором `logging`.
# Это делает `logging` обработку аргументов и выводит информацию о вызове функции.
# 2. Далее в `wrapped_func` от `logging` происходит вызов следующей завертки – `wrapped_func` от `timer`, которая
# начинает отсчет времени.
# 3. `Timer` вызывает первоначальную функцию `squares_sum`, выполняет ее и получает результат.
# 4. После завершения функции `squares_sum`, управление возвращается в `wrapped_func` от `timer`, где вычисляется время выполнения и выводится на экран.
# 5. Затем управление возвращается в `wrapped_func` от `logging`, где выводится информация о завершении работы функции.
# 6. В конечном итоге результат из `squares_sum` возвращается обратно через оба декоратора.

# ### Визуализация взаимодействия
#
# Визуально взаимодействие можно представить в виде стека вызовов:
#
# squares_sum()  # вы вызываете эту функцию
# ↓
# logging.wrapped_func()  # вызов первого декоратора
# ↓
# timer.wrapped_func()    # вызов второго декоратора
# ↓
# squares_sum()          # оригинальная функция
#
#
# ### Важные моменты
#
# - Порядок декораторов имеет значение. Если поменять местами `@logging` и `@timer`, сначала вы получите логирование,
# а только потом будете измерять время выполнения, что искажает результаты (время логирования также будет учитываться
# в общем времени).
# - Каждый декоратор может изменять входные параметры и/или выходные результаты функции, что позволяет использовать
# мощные конструкции для обёртки функций.
#
# В итоге, взаимодействие двух декораторов позволяет добавлять новые функции (логирование, замеры времени) к одной и
# той же функции, не модифицируя её непосредственно, а просто оборачивая её в новые функции с дополнительной
# функциональностью.
