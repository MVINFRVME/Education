# ### Пример вызова `fibonacci(5)`

# 1. **Первый вызов**:
#   - Вызывается `fibonacci(5)`.
#   - Поскольку 5 ≥ 2, функция переходит к следующему выражению.
#   - Вызов функции продолжается: `fibonacci(5)` вызывает `fibonacci(4)` и `fibonacci(3)`.

# 2. **Второй уровень**:
#   - Для `fibonacci(4)`:
#      - Это также ≥ 2, поэтому вызывается: `fibonacci(4)` вызывает `fibonacci(3)` и `fibonacci(2)`.
#   - Для `fibonacci(3)`:
#      - Это также ≥ 2, поэтому вызывается: `fibonacci(3)` вызывает `fibonacci(2)` и `fibonacci(1)`.

# 3. **Третий уровень**:
#   - Для `fibonacci(3)` (из `fibonacci(4)`):
#      - `fibonacci(2)` вызывает `fibonacci(1)` и `fibonacci(0)`.
#   - Для `fibonacci(2)` (из `fibonacci(3)`):
#      - Это снова ≥ 2, и вызывает `fibonacci(1)` и `fibonacci(0)`.

# 4. **Четвертый уровень (Базовые случаи)**:
#   - Вызовы функций достигают базовых случаев:
#      - `fibonacci(1)` возвращает 1.
#      - `fibonacci(0)` возвращает 0.
#   - Теперь мы можем подставлять результаты обратно в предыдущие вызовы.

# ### Итоговая последовательность вызовов:

# Теперь давайте соберём все вызовы вместе в дерево вызовов и пронумеруем их:


# fibonacci(5)
# ├── fibonacci(4)
# │   ├── fibonacci(3)
# │   │   ├── fibonacci(2)
# │   │   │   ├── fibonacci(1)  → 1
# │   │   │   └── fibonacci(0)  → 0
# │   │   └── fibonacci(1)      → 1
# │   └── fibonacci(2)
# │       ├── fibonacci(1)      → 1
# │       └── fibonacci(0)      → 0
# └── fibonacci(3)
#     ├── fibonacci(2)
#     │   ├── fibonacci(1)      → 1
#     │   └── fibonacci(0)      → 0
#     └── fibonacci(1)          → 1


# ### Подсчет результатов:

# Сейчас, давайте подставим результаты и посчитаем n-е число Фибоначчи:

# 1. Получаем от `fibonacci(0)`: 0
# 2. Получаем от `fibonacci(1)`: 1
# 3. `fibonacci(2)` = 1 + 0 = 1
# 4. `fibonacci(3)` = 1 + 1 = 2
# 5. `fibonacci(4)` = 2 + 1 = 3
# 6. `fibonacci(5)` = 3 + 2 = 5

# Таким образом, результат для `fibonacci(5)` равен 5.

# ### Заключение:

# - Процесс продолжается до тех пор, пока не будут достигнуты базовые случаи (0 и 1), после чего, начиная с минимальных
# значений, результаты возвращаются вверх по дереву вызовов.
# - Обратите внимание, что из-за рекурсивного характера функции этот подход имеет экспоненциальную сложность O(2^n).
# Использование кэширования или итеративных методов, как уже упоминалось ранее, значительно улучшит производительность
# для больших `n`.

def fibonacci(n):
    if n < 2:
        return n
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)


print(fibonacci(5))
